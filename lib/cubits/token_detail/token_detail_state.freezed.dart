// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'token_detail_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$TokenDetailSecurityState {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TokenDetailSecurityState);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenDetailSecurityState()';
}


}

/// @nodoc
class $TokenDetailSecurityStateCopyWith<$Res>  {
$TokenDetailSecurityStateCopyWith(TokenDetailSecurityState _, $Res Function(TokenDetailSecurityState) __);
}


/// Adds pattern-matching-related methods to [TokenDetailSecurityState].
extension TokenDetailSecurityStatePatterns on TokenDetailSecurityState {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _TokenDetailSecurityInitial value)?  initial,TResult Function( _TokenDetailSecurityLoading value)?  loading,TResult Function( _TokenDetailSecuritySuccess value)?  success,TResult Function( _TokenDetailSecurityError value)?  error,required TResult orElse(),}){
final _that = this;
switch (_that) {
case _TokenDetailSecurityInitial() when initial != null:
return initial(_that);case _TokenDetailSecurityLoading() when loading != null:
return loading(_that);case _TokenDetailSecuritySuccess() when success != null:
return success(_that);case _TokenDetailSecurityError() when error != null:
return error(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _TokenDetailSecurityInitial value)  initial,required TResult Function( _TokenDetailSecurityLoading value)  loading,required TResult Function( _TokenDetailSecuritySuccess value)  success,required TResult Function( _TokenDetailSecurityError value)  error,}){
final _that = this;
switch (_that) {
case _TokenDetailSecurityInitial():
return initial(_that);case _TokenDetailSecurityLoading():
return loading(_that);case _TokenDetailSecuritySuccess():
return success(_that);case _TokenDetailSecurityError():
return error(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _TokenDetailSecurityInitial value)?  initial,TResult? Function( _TokenDetailSecurityLoading value)?  loading,TResult? Function( _TokenDetailSecuritySuccess value)?  success,TResult? Function( _TokenDetailSecurityError value)?  error,}){
final _that = this;
switch (_that) {
case _TokenDetailSecurityInitial() when initial != null:
return initial(_that);case _TokenDetailSecurityLoading() when loading != null:
return loading(_that);case _TokenDetailSecuritySuccess() when success != null:
return success(_that);case _TokenDetailSecurityError() when error != null:
return error(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  initial,TResult Function()?  loading,TResult Function( TokenDetailSecurity tokenDetailSecurity)?  success,TResult Function( String message)?  error,required TResult orElse(),}) {final _that = this;
switch (_that) {
case _TokenDetailSecurityInitial() when initial != null:
return initial();case _TokenDetailSecurityLoading() when loading != null:
return loading();case _TokenDetailSecuritySuccess() when success != null:
return success(_that.tokenDetailSecurity);case _TokenDetailSecurityError() when error != null:
return error(_that.message);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  initial,required TResult Function()  loading,required TResult Function( TokenDetailSecurity tokenDetailSecurity)  success,required TResult Function( String message)  error,}) {final _that = this;
switch (_that) {
case _TokenDetailSecurityInitial():
return initial();case _TokenDetailSecurityLoading():
return loading();case _TokenDetailSecuritySuccess():
return success(_that.tokenDetailSecurity);case _TokenDetailSecurityError():
return error(_that.message);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  initial,TResult? Function()?  loading,TResult? Function( TokenDetailSecurity tokenDetailSecurity)?  success,TResult? Function( String message)?  error,}) {final _that = this;
switch (_that) {
case _TokenDetailSecurityInitial() when initial != null:
return initial();case _TokenDetailSecurityLoading() when loading != null:
return loading();case _TokenDetailSecuritySuccess() when success != null:
return success(_that.tokenDetailSecurity);case _TokenDetailSecurityError() when error != null:
return error(_that.message);case _:
  return null;

}
}

}

/// @nodoc


class _TokenDetailSecurityInitial implements TokenDetailSecurityState {
  const _TokenDetailSecurityInitial();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenDetailSecurityInitial);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenDetailSecurityState.initial()';
}


}




/// @nodoc


class _TokenDetailSecurityLoading implements TokenDetailSecurityState {
  const _TokenDetailSecurityLoading();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenDetailSecurityLoading);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenDetailSecurityState.loading()';
}


}




/// @nodoc


class _TokenDetailSecuritySuccess implements TokenDetailSecurityState {
  const _TokenDetailSecuritySuccess(this.tokenDetailSecurity);
  

 final  TokenDetailSecurity tokenDetailSecurity;

/// Create a copy of TokenDetailSecurityState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TokenDetailSecuritySuccessCopyWith<_TokenDetailSecuritySuccess> get copyWith => __$TokenDetailSecuritySuccessCopyWithImpl<_TokenDetailSecuritySuccess>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenDetailSecuritySuccess&&(identical(other.tokenDetailSecurity, tokenDetailSecurity) || other.tokenDetailSecurity == tokenDetailSecurity));
}


@override
int get hashCode => Object.hash(runtimeType,tokenDetailSecurity);

@override
String toString() {
  return 'TokenDetailSecurityState.success(tokenDetailSecurity: $tokenDetailSecurity)';
}


}

/// @nodoc
abstract mixin class _$TokenDetailSecuritySuccessCopyWith<$Res> implements $TokenDetailSecurityStateCopyWith<$Res> {
  factory _$TokenDetailSecuritySuccessCopyWith(_TokenDetailSecuritySuccess value, $Res Function(_TokenDetailSecuritySuccess) _then) = __$TokenDetailSecuritySuccessCopyWithImpl;
@useResult
$Res call({
 TokenDetailSecurity tokenDetailSecurity
});


$TokenDetailSecurityCopyWith<$Res> get tokenDetailSecurity;

}
/// @nodoc
class __$TokenDetailSecuritySuccessCopyWithImpl<$Res>
    implements _$TokenDetailSecuritySuccessCopyWith<$Res> {
  __$TokenDetailSecuritySuccessCopyWithImpl(this._self, this._then);

  final _TokenDetailSecuritySuccess _self;
  final $Res Function(_TokenDetailSecuritySuccess) _then;

/// Create a copy of TokenDetailSecurityState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? tokenDetailSecurity = null,}) {
  return _then(_TokenDetailSecuritySuccess(
null == tokenDetailSecurity ? _self.tokenDetailSecurity : tokenDetailSecurity // ignore: cast_nullable_to_non_nullable
as TokenDetailSecurity,
  ));
}

/// Create a copy of TokenDetailSecurityState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenDetailSecurityCopyWith<$Res> get tokenDetailSecurity {
  
  return $TokenDetailSecurityCopyWith<$Res>(_self.tokenDetailSecurity, (value) {
    return _then(_self.copyWith(tokenDetailSecurity: value));
  });
}
}

/// @nodoc


class _TokenDetailSecurityError implements TokenDetailSecurityState {
  const _TokenDetailSecurityError(this.message);
  

 final  String message;

/// Create a copy of TokenDetailSecurityState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TokenDetailSecurityErrorCopyWith<_TokenDetailSecurityError> get copyWith => __$TokenDetailSecurityErrorCopyWithImpl<_TokenDetailSecurityError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenDetailSecurityError&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'TokenDetailSecurityState.error(message: $message)';
}


}

/// @nodoc
abstract mixin class _$TokenDetailSecurityErrorCopyWith<$Res> implements $TokenDetailSecurityStateCopyWith<$Res> {
  factory _$TokenDetailSecurityErrorCopyWith(_TokenDetailSecurityError value, $Res Function(_TokenDetailSecurityError) _then) = __$TokenDetailSecurityErrorCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class __$TokenDetailSecurityErrorCopyWithImpl<$Res>
    implements _$TokenDetailSecurityErrorCopyWith<$Res> {
  __$TokenDetailSecurityErrorCopyWithImpl(this._self, this._then);

  final _TokenDetailSecurityError _self;
  final $Res Function(_TokenDetailSecurityError) _then;

/// Create a copy of TokenDetailSecurityState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(_TokenDetailSecurityError(
null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc
mixin _$TokenDetailIntelState {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TokenDetailIntelState);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenDetailIntelState()';
}


}

/// @nodoc
class $TokenDetailIntelStateCopyWith<$Res>  {
$TokenDetailIntelStateCopyWith(TokenDetailIntelState _, $Res Function(TokenDetailIntelState) __);
}


/// Adds pattern-matching-related methods to [TokenDetailIntelState].
extension TokenDetailIntelStatePatterns on TokenDetailIntelState {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _TokenDetailIntelInitial value)?  initial,TResult Function( _TokenDetailIntelLoading value)?  loading,TResult Function( _TokenDetailIntelSuccess value)?  success,TResult Function( _TokenDetailIntelError value)?  error,required TResult orElse(),}){
final _that = this;
switch (_that) {
case _TokenDetailIntelInitial() when initial != null:
return initial(_that);case _TokenDetailIntelLoading() when loading != null:
return loading(_that);case _TokenDetailIntelSuccess() when success != null:
return success(_that);case _TokenDetailIntelError() when error != null:
return error(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _TokenDetailIntelInitial value)  initial,required TResult Function( _TokenDetailIntelLoading value)  loading,required TResult Function( _TokenDetailIntelSuccess value)  success,required TResult Function( _TokenDetailIntelError value)  error,}){
final _that = this;
switch (_that) {
case _TokenDetailIntelInitial():
return initial(_that);case _TokenDetailIntelLoading():
return loading(_that);case _TokenDetailIntelSuccess():
return success(_that);case _TokenDetailIntelError():
return error(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _TokenDetailIntelInitial value)?  initial,TResult? Function( _TokenDetailIntelLoading value)?  loading,TResult? Function( _TokenDetailIntelSuccess value)?  success,TResult? Function( _TokenDetailIntelError value)?  error,}){
final _that = this;
switch (_that) {
case _TokenDetailIntelInitial() when initial != null:
return initial(_that);case _TokenDetailIntelLoading() when loading != null:
return loading(_that);case _TokenDetailIntelSuccess() when success != null:
return success(_that);case _TokenDetailIntelError() when error != null:
return error(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  initial,TResult Function()?  loading,TResult Function( Intel intel)?  success,TResult Function( String message)?  error,required TResult orElse(),}) {final _that = this;
switch (_that) {
case _TokenDetailIntelInitial() when initial != null:
return initial();case _TokenDetailIntelLoading() when loading != null:
return loading();case _TokenDetailIntelSuccess() when success != null:
return success(_that.intel);case _TokenDetailIntelError() when error != null:
return error(_that.message);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  initial,required TResult Function()  loading,required TResult Function( Intel intel)  success,required TResult Function( String message)  error,}) {final _that = this;
switch (_that) {
case _TokenDetailIntelInitial():
return initial();case _TokenDetailIntelLoading():
return loading();case _TokenDetailIntelSuccess():
return success(_that.intel);case _TokenDetailIntelError():
return error(_that.message);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  initial,TResult? Function()?  loading,TResult? Function( Intel intel)?  success,TResult? Function( String message)?  error,}) {final _that = this;
switch (_that) {
case _TokenDetailIntelInitial() when initial != null:
return initial();case _TokenDetailIntelLoading() when loading != null:
return loading();case _TokenDetailIntelSuccess() when success != null:
return success(_that.intel);case _TokenDetailIntelError() when error != null:
return error(_that.message);case _:
  return null;

}
}

}

/// @nodoc


class _TokenDetailIntelInitial implements TokenDetailIntelState {
  const _TokenDetailIntelInitial();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenDetailIntelInitial);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenDetailIntelState.initial()';
}


}




/// @nodoc


class _TokenDetailIntelLoading implements TokenDetailIntelState {
  const _TokenDetailIntelLoading();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenDetailIntelLoading);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenDetailIntelState.loading()';
}


}




/// @nodoc


class _TokenDetailIntelSuccess implements TokenDetailIntelState {
  const _TokenDetailIntelSuccess(this.intel);
  

 final  Intel intel;

/// Create a copy of TokenDetailIntelState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TokenDetailIntelSuccessCopyWith<_TokenDetailIntelSuccess> get copyWith => __$TokenDetailIntelSuccessCopyWithImpl<_TokenDetailIntelSuccess>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenDetailIntelSuccess&&(identical(other.intel, intel) || other.intel == intel));
}


@override
int get hashCode => Object.hash(runtimeType,intel);

@override
String toString() {
  return 'TokenDetailIntelState.success(intel: $intel)';
}


}

/// @nodoc
abstract mixin class _$TokenDetailIntelSuccessCopyWith<$Res> implements $TokenDetailIntelStateCopyWith<$Res> {
  factory _$TokenDetailIntelSuccessCopyWith(_TokenDetailIntelSuccess value, $Res Function(_TokenDetailIntelSuccess) _then) = __$TokenDetailIntelSuccessCopyWithImpl;
@useResult
$Res call({
 Intel intel
});


$IntelCopyWith<$Res> get intel;

}
/// @nodoc
class __$TokenDetailIntelSuccessCopyWithImpl<$Res>
    implements _$TokenDetailIntelSuccessCopyWith<$Res> {
  __$TokenDetailIntelSuccessCopyWithImpl(this._self, this._then);

  final _TokenDetailIntelSuccess _self;
  final $Res Function(_TokenDetailIntelSuccess) _then;

/// Create a copy of TokenDetailIntelState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? intel = null,}) {
  return _then(_TokenDetailIntelSuccess(
null == intel ? _self.intel : intel // ignore: cast_nullable_to_non_nullable
as Intel,
  ));
}

/// Create a copy of TokenDetailIntelState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$IntelCopyWith<$Res> get intel {
  
  return $IntelCopyWith<$Res>(_self.intel, (value) {
    return _then(_self.copyWith(intel: value));
  });
}
}

/// @nodoc


class _TokenDetailIntelError implements TokenDetailIntelState {
  const _TokenDetailIntelError(this.message);
  

 final  String message;

/// Create a copy of TokenDetailIntelState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TokenDetailIntelErrorCopyWith<_TokenDetailIntelError> get copyWith => __$TokenDetailIntelErrorCopyWithImpl<_TokenDetailIntelError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenDetailIntelError&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'TokenDetailIntelState.error(message: $message)';
}


}

/// @nodoc
abstract mixin class _$TokenDetailIntelErrorCopyWith<$Res> implements $TokenDetailIntelStateCopyWith<$Res> {
  factory _$TokenDetailIntelErrorCopyWith(_TokenDetailIntelError value, $Res Function(_TokenDetailIntelError) _then) = __$TokenDetailIntelErrorCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class __$TokenDetailIntelErrorCopyWithImpl<$Res>
    implements _$TokenDetailIntelErrorCopyWith<$Res> {
  __$TokenDetailIntelErrorCopyWithImpl(this._self, this._then);

  final _TokenDetailIntelError _self;
  final $Res Function(_TokenDetailIntelError) _then;

/// Create a copy of TokenDetailIntelState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(_TokenDetailIntelError(
null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc
mixin _$TokenDetailUrlsState {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TokenDetailUrlsState);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenDetailUrlsState()';
}


}

/// @nodoc
class $TokenDetailUrlsStateCopyWith<$Res>  {
$TokenDetailUrlsStateCopyWith(TokenDetailUrlsState _, $Res Function(TokenDetailUrlsState) __);
}


/// Adds pattern-matching-related methods to [TokenDetailUrlsState].
extension TokenDetailUrlsStatePatterns on TokenDetailUrlsState {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _TokenDetailUrlsInitial value)?  initial,TResult Function( _TokenDetailUrlsLoading value)?  loading,TResult Function( _TokenDetailUrlsSuccess value)?  success,TResult Function( _TokenDetailUrlsError value)?  error,required TResult orElse(),}){
final _that = this;
switch (_that) {
case _TokenDetailUrlsInitial() when initial != null:
return initial(_that);case _TokenDetailUrlsLoading() when loading != null:
return loading(_that);case _TokenDetailUrlsSuccess() when success != null:
return success(_that);case _TokenDetailUrlsError() when error != null:
return error(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _TokenDetailUrlsInitial value)  initial,required TResult Function( _TokenDetailUrlsLoading value)  loading,required TResult Function( _TokenDetailUrlsSuccess value)  success,required TResult Function( _TokenDetailUrlsError value)  error,}){
final _that = this;
switch (_that) {
case _TokenDetailUrlsInitial():
return initial(_that);case _TokenDetailUrlsLoading():
return loading(_that);case _TokenDetailUrlsSuccess():
return success(_that);case _TokenDetailUrlsError():
return error(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _TokenDetailUrlsInitial value)?  initial,TResult? Function( _TokenDetailUrlsLoading value)?  loading,TResult? Function( _TokenDetailUrlsSuccess value)?  success,TResult? Function( _TokenDetailUrlsError value)?  error,}){
final _that = this;
switch (_that) {
case _TokenDetailUrlsInitial() when initial != null:
return initial(_that);case _TokenDetailUrlsLoading() when loading != null:
return loading(_that);case _TokenDetailUrlsSuccess() when success != null:
return success(_that);case _TokenDetailUrlsError() when error != null:
return error(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  initial,TResult Function()?  loading,TResult Function( TokenDetailUrls tokenDetailUrls)?  success,TResult Function()?  error,required TResult orElse(),}) {final _that = this;
switch (_that) {
case _TokenDetailUrlsInitial() when initial != null:
return initial();case _TokenDetailUrlsLoading() when loading != null:
return loading();case _TokenDetailUrlsSuccess() when success != null:
return success(_that.tokenDetailUrls);case _TokenDetailUrlsError() when error != null:
return error();case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  initial,required TResult Function()  loading,required TResult Function( TokenDetailUrls tokenDetailUrls)  success,required TResult Function()  error,}) {final _that = this;
switch (_that) {
case _TokenDetailUrlsInitial():
return initial();case _TokenDetailUrlsLoading():
return loading();case _TokenDetailUrlsSuccess():
return success(_that.tokenDetailUrls);case _TokenDetailUrlsError():
return error();case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  initial,TResult? Function()?  loading,TResult? Function( TokenDetailUrls tokenDetailUrls)?  success,TResult? Function()?  error,}) {final _that = this;
switch (_that) {
case _TokenDetailUrlsInitial() when initial != null:
return initial();case _TokenDetailUrlsLoading() when loading != null:
return loading();case _TokenDetailUrlsSuccess() when success != null:
return success(_that.tokenDetailUrls);case _TokenDetailUrlsError() when error != null:
return error();case _:
  return null;

}
}

}

/// @nodoc


class _TokenDetailUrlsInitial implements TokenDetailUrlsState {
  const _TokenDetailUrlsInitial();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenDetailUrlsInitial);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenDetailUrlsState.initial()';
}


}




/// @nodoc


class _TokenDetailUrlsLoading implements TokenDetailUrlsState {
  const _TokenDetailUrlsLoading();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenDetailUrlsLoading);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenDetailUrlsState.loading()';
}


}




/// @nodoc


class _TokenDetailUrlsSuccess implements TokenDetailUrlsState {
  const _TokenDetailUrlsSuccess(this.tokenDetailUrls);
  

 final  TokenDetailUrls tokenDetailUrls;

/// Create a copy of TokenDetailUrlsState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TokenDetailUrlsSuccessCopyWith<_TokenDetailUrlsSuccess> get copyWith => __$TokenDetailUrlsSuccessCopyWithImpl<_TokenDetailUrlsSuccess>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenDetailUrlsSuccess&&(identical(other.tokenDetailUrls, tokenDetailUrls) || other.tokenDetailUrls == tokenDetailUrls));
}


@override
int get hashCode => Object.hash(runtimeType,tokenDetailUrls);

@override
String toString() {
  return 'TokenDetailUrlsState.success(tokenDetailUrls: $tokenDetailUrls)';
}


}

/// @nodoc
abstract mixin class _$TokenDetailUrlsSuccessCopyWith<$Res> implements $TokenDetailUrlsStateCopyWith<$Res> {
  factory _$TokenDetailUrlsSuccessCopyWith(_TokenDetailUrlsSuccess value, $Res Function(_TokenDetailUrlsSuccess) _then) = __$TokenDetailUrlsSuccessCopyWithImpl;
@useResult
$Res call({
 TokenDetailUrls tokenDetailUrls
});


$TokenDetailUrlsCopyWith<$Res> get tokenDetailUrls;

}
/// @nodoc
class __$TokenDetailUrlsSuccessCopyWithImpl<$Res>
    implements _$TokenDetailUrlsSuccessCopyWith<$Res> {
  __$TokenDetailUrlsSuccessCopyWithImpl(this._self, this._then);

  final _TokenDetailUrlsSuccess _self;
  final $Res Function(_TokenDetailUrlsSuccess) _then;

/// Create a copy of TokenDetailUrlsState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? tokenDetailUrls = null,}) {
  return _then(_TokenDetailUrlsSuccess(
null == tokenDetailUrls ? _self.tokenDetailUrls : tokenDetailUrls // ignore: cast_nullable_to_non_nullable
as TokenDetailUrls,
  ));
}

/// Create a copy of TokenDetailUrlsState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenDetailUrlsCopyWith<$Res> get tokenDetailUrls {
  
  return $TokenDetailUrlsCopyWith<$Res>(_self.tokenDetailUrls, (value) {
    return _then(_self.copyWith(tokenDetailUrls: value));
  });
}
}

/// @nodoc


class _TokenDetailUrlsError implements TokenDetailUrlsState {
  const _TokenDetailUrlsError();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenDetailUrlsError);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenDetailUrlsState.error()';
}


}




/// @nodoc
mixin _$TokenHoldingsState {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TokenHoldingsState);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenHoldingsState()';
}


}

/// @nodoc
class $TokenHoldingsStateCopyWith<$Res>  {
$TokenHoldingsStateCopyWith(TokenHoldingsState _, $Res Function(TokenHoldingsState) __);
}


/// Adds pattern-matching-related methods to [TokenHoldingsState].
extension TokenHoldingsStatePatterns on TokenHoldingsState {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _TokenHoldingsInitial value)?  initial,TResult Function( _TokenHoldingsLoading value)?  loading,TResult Function( _TokenHoldingsSuccess value)?  success,TResult Function( _TokenHoldingsError value)?  error,required TResult orElse(),}){
final _that = this;
switch (_that) {
case _TokenHoldingsInitial() when initial != null:
return initial(_that);case _TokenHoldingsLoading() when loading != null:
return loading(_that);case _TokenHoldingsSuccess() when success != null:
return success(_that);case _TokenHoldingsError() when error != null:
return error(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _TokenHoldingsInitial value)  initial,required TResult Function( _TokenHoldingsLoading value)  loading,required TResult Function( _TokenHoldingsSuccess value)  success,required TResult Function( _TokenHoldingsError value)  error,}){
final _that = this;
switch (_that) {
case _TokenHoldingsInitial():
return initial(_that);case _TokenHoldingsLoading():
return loading(_that);case _TokenHoldingsSuccess():
return success(_that);case _TokenHoldingsError():
return error(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _TokenHoldingsInitial value)?  initial,TResult? Function( _TokenHoldingsLoading value)?  loading,TResult? Function( _TokenHoldingsSuccess value)?  success,TResult? Function( _TokenHoldingsError value)?  error,}){
final _that = this;
switch (_that) {
case _TokenHoldingsInitial() when initial != null:
return initial(_that);case _TokenHoldingsLoading() when loading != null:
return loading(_that);case _TokenHoldingsSuccess() when success != null:
return success(_that);case _TokenHoldingsError() when error != null:
return error(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  initial,TResult Function()?  loading,TResult Function( List<dynamic> tokenHoldings)?  success,TResult Function( String message)?  error,required TResult orElse(),}) {final _that = this;
switch (_that) {
case _TokenHoldingsInitial() when initial != null:
return initial();case _TokenHoldingsLoading() when loading != null:
return loading();case _TokenHoldingsSuccess() when success != null:
return success(_that.tokenHoldings);case _TokenHoldingsError() when error != null:
return error(_that.message);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  initial,required TResult Function()  loading,required TResult Function( List<dynamic> tokenHoldings)  success,required TResult Function( String message)  error,}) {final _that = this;
switch (_that) {
case _TokenHoldingsInitial():
return initial();case _TokenHoldingsLoading():
return loading();case _TokenHoldingsSuccess():
return success(_that.tokenHoldings);case _TokenHoldingsError():
return error(_that.message);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  initial,TResult? Function()?  loading,TResult? Function( List<dynamic> tokenHoldings)?  success,TResult? Function( String message)?  error,}) {final _that = this;
switch (_that) {
case _TokenHoldingsInitial() when initial != null:
return initial();case _TokenHoldingsLoading() when loading != null:
return loading();case _TokenHoldingsSuccess() when success != null:
return success(_that.tokenHoldings);case _TokenHoldingsError() when error != null:
return error(_that.message);case _:
  return null;

}
}

}

/// @nodoc


class _TokenHoldingsInitial implements TokenHoldingsState {
  const _TokenHoldingsInitial();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenHoldingsInitial);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenHoldingsState.initial()';
}


}




/// @nodoc


class _TokenHoldingsLoading implements TokenHoldingsState {
  const _TokenHoldingsLoading();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenHoldingsLoading);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenHoldingsState.loading()';
}


}




/// @nodoc


class _TokenHoldingsSuccess implements TokenHoldingsState {
  const _TokenHoldingsSuccess(final  List<dynamic> tokenHoldings): _tokenHoldings = tokenHoldings;
  

 final  List<dynamic> _tokenHoldings;
 List<dynamic> get tokenHoldings {
  if (_tokenHoldings is EqualUnmodifiableListView) return _tokenHoldings;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_tokenHoldings);
}


/// Create a copy of TokenHoldingsState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TokenHoldingsSuccessCopyWith<_TokenHoldingsSuccess> get copyWith => __$TokenHoldingsSuccessCopyWithImpl<_TokenHoldingsSuccess>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenHoldingsSuccess&&const DeepCollectionEquality().equals(other._tokenHoldings, _tokenHoldings));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_tokenHoldings));

@override
String toString() {
  return 'TokenHoldingsState.success(tokenHoldings: $tokenHoldings)';
}


}

/// @nodoc
abstract mixin class _$TokenHoldingsSuccessCopyWith<$Res> implements $TokenHoldingsStateCopyWith<$Res> {
  factory _$TokenHoldingsSuccessCopyWith(_TokenHoldingsSuccess value, $Res Function(_TokenHoldingsSuccess) _then) = __$TokenHoldingsSuccessCopyWithImpl;
@useResult
$Res call({
 List<dynamic> tokenHoldings
});




}
/// @nodoc
class __$TokenHoldingsSuccessCopyWithImpl<$Res>
    implements _$TokenHoldingsSuccessCopyWith<$Res> {
  __$TokenHoldingsSuccessCopyWithImpl(this._self, this._then);

  final _TokenHoldingsSuccess _self;
  final $Res Function(_TokenHoldingsSuccess) _then;

/// Create a copy of TokenHoldingsState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? tokenHoldings = null,}) {
  return _then(_TokenHoldingsSuccess(
null == tokenHoldings ? _self._tokenHoldings : tokenHoldings // ignore: cast_nullable_to_non_nullable
as List<dynamic>,
  ));
}


}

/// @nodoc


class _TokenHoldingsError implements TokenHoldingsState {
  const _TokenHoldingsError(this.message);
  

 final  String message;

/// Create a copy of TokenHoldingsState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TokenHoldingsErrorCopyWith<_TokenHoldingsError> get copyWith => __$TokenHoldingsErrorCopyWithImpl<_TokenHoldingsError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenHoldingsError&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'TokenHoldingsState.error(message: $message)';
}


}

/// @nodoc
abstract mixin class _$TokenHoldingsErrorCopyWith<$Res> implements $TokenHoldingsStateCopyWith<$Res> {
  factory _$TokenHoldingsErrorCopyWith(_TokenHoldingsError value, $Res Function(_TokenHoldingsError) _then) = __$TokenHoldingsErrorCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class __$TokenHoldingsErrorCopyWithImpl<$Res>
    implements _$TokenHoldingsErrorCopyWith<$Res> {
  __$TokenHoldingsErrorCopyWithImpl(this._self, this._then);

  final _TokenHoldingsError _self;
  final $Res Function(_TokenHoldingsError) _then;

/// Create a copy of TokenHoldingsState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(_TokenHoldingsError(
null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc
mixin _$TokenIntelCountState {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TokenIntelCountState);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenIntelCountState()';
}


}

/// @nodoc
class $TokenIntelCountStateCopyWith<$Res>  {
$TokenIntelCountStateCopyWith(TokenIntelCountState _, $Res Function(TokenIntelCountState) __);
}


/// Adds pattern-matching-related methods to [TokenIntelCountState].
extension TokenIntelCountStatePatterns on TokenIntelCountState {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _TokenIntelCountInitial value)?  initial,TResult Function( _TokenIntelCountLoading value)?  loading,TResult Function( _TokenIntelCountSuccess value)?  success,TResult Function( _TokenIntelCountError value)?  error,required TResult orElse(),}){
final _that = this;
switch (_that) {
case _TokenIntelCountInitial() when initial != null:
return initial(_that);case _TokenIntelCountLoading() when loading != null:
return loading(_that);case _TokenIntelCountSuccess() when success != null:
return success(_that);case _TokenIntelCountError() when error != null:
return error(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _TokenIntelCountInitial value)  initial,required TResult Function( _TokenIntelCountLoading value)  loading,required TResult Function( _TokenIntelCountSuccess value)  success,required TResult Function( _TokenIntelCountError value)  error,}){
final _that = this;
switch (_that) {
case _TokenIntelCountInitial():
return initial(_that);case _TokenIntelCountLoading():
return loading(_that);case _TokenIntelCountSuccess():
return success(_that);case _TokenIntelCountError():
return error(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _TokenIntelCountInitial value)?  initial,TResult? Function( _TokenIntelCountLoading value)?  loading,TResult? Function( _TokenIntelCountSuccess value)?  success,TResult? Function( _TokenIntelCountError value)?  error,}){
final _that = this;
switch (_that) {
case _TokenIntelCountInitial() when initial != null:
return initial(_that);case _TokenIntelCountLoading() when loading != null:
return loading(_that);case _TokenIntelCountSuccess() when success != null:
return success(_that);case _TokenIntelCountError() when error != null:
return error(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  initial,TResult Function()?  loading,TResult Function( int tokenIntelCount)?  success,TResult Function( String message)?  error,required TResult orElse(),}) {final _that = this;
switch (_that) {
case _TokenIntelCountInitial() when initial != null:
return initial();case _TokenIntelCountLoading() when loading != null:
return loading();case _TokenIntelCountSuccess() when success != null:
return success(_that.tokenIntelCount);case _TokenIntelCountError() when error != null:
return error(_that.message);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  initial,required TResult Function()  loading,required TResult Function( int tokenIntelCount)  success,required TResult Function( String message)  error,}) {final _that = this;
switch (_that) {
case _TokenIntelCountInitial():
return initial();case _TokenIntelCountLoading():
return loading();case _TokenIntelCountSuccess():
return success(_that.tokenIntelCount);case _TokenIntelCountError():
return error(_that.message);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  initial,TResult? Function()?  loading,TResult? Function( int tokenIntelCount)?  success,TResult? Function( String message)?  error,}) {final _that = this;
switch (_that) {
case _TokenIntelCountInitial() when initial != null:
return initial();case _TokenIntelCountLoading() when loading != null:
return loading();case _TokenIntelCountSuccess() when success != null:
return success(_that.tokenIntelCount);case _TokenIntelCountError() when error != null:
return error(_that.message);case _:
  return null;

}
}

}

/// @nodoc


class _TokenIntelCountInitial implements TokenIntelCountState {
  const _TokenIntelCountInitial();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenIntelCountInitial);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenIntelCountState.initial()';
}


}




/// @nodoc


class _TokenIntelCountLoading implements TokenIntelCountState {
  const _TokenIntelCountLoading();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenIntelCountLoading);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenIntelCountState.loading()';
}


}




/// @nodoc


class _TokenIntelCountSuccess implements TokenIntelCountState {
  const _TokenIntelCountSuccess(this.tokenIntelCount);
  

 final  int tokenIntelCount;

/// Create a copy of TokenIntelCountState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TokenIntelCountSuccessCopyWith<_TokenIntelCountSuccess> get copyWith => __$TokenIntelCountSuccessCopyWithImpl<_TokenIntelCountSuccess>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenIntelCountSuccess&&(identical(other.tokenIntelCount, tokenIntelCount) || other.tokenIntelCount == tokenIntelCount));
}


@override
int get hashCode => Object.hash(runtimeType,tokenIntelCount);

@override
String toString() {
  return 'TokenIntelCountState.success(tokenIntelCount: $tokenIntelCount)';
}


}

/// @nodoc
abstract mixin class _$TokenIntelCountSuccessCopyWith<$Res> implements $TokenIntelCountStateCopyWith<$Res> {
  factory _$TokenIntelCountSuccessCopyWith(_TokenIntelCountSuccess value, $Res Function(_TokenIntelCountSuccess) _then) = __$TokenIntelCountSuccessCopyWithImpl;
@useResult
$Res call({
 int tokenIntelCount
});




}
/// @nodoc
class __$TokenIntelCountSuccessCopyWithImpl<$Res>
    implements _$TokenIntelCountSuccessCopyWith<$Res> {
  __$TokenIntelCountSuccessCopyWithImpl(this._self, this._then);

  final _TokenIntelCountSuccess _self;
  final $Res Function(_TokenIntelCountSuccess) _then;

/// Create a copy of TokenIntelCountState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? tokenIntelCount = null,}) {
  return _then(_TokenIntelCountSuccess(
null == tokenIntelCount ? _self.tokenIntelCount : tokenIntelCount // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

/// @nodoc


class _TokenIntelCountError implements TokenIntelCountState {
  const _TokenIntelCountError(this.message);
  

 final  String message;

/// Create a copy of TokenIntelCountState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TokenIntelCountErrorCopyWith<_TokenIntelCountError> get copyWith => __$TokenIntelCountErrorCopyWithImpl<_TokenIntelCountError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenIntelCountError&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'TokenIntelCountState.error(message: $message)';
}


}

/// @nodoc
abstract mixin class _$TokenIntelCountErrorCopyWith<$Res> implements $TokenIntelCountStateCopyWith<$Res> {
  factory _$TokenIntelCountErrorCopyWith(_TokenIntelCountError value, $Res Function(_TokenIntelCountError) _then) = __$TokenIntelCountErrorCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class __$TokenIntelCountErrorCopyWithImpl<$Res>
    implements _$TokenIntelCountErrorCopyWith<$Res> {
  __$TokenIntelCountErrorCopyWithImpl(this._self, this._then);

  final _TokenIntelCountError _self;
  final $Res Function(_TokenIntelCountError) _then;

/// Create a copy of TokenIntelCountState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(_TokenIntelCountError(
null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc
mixin _$TokenDetailState {

 Token? get token; TokenDetailSecurity? get securitys; TokenDetailInfo? get tokenDetailInfo; int get tokenAssociatedIntelsPage; int get tokenAssociatedIntelsPageSize; List<dynamic>? get tokenHoldings; bool get isNotMore; TokenDetailUrls? get tokenUrls; int get tokenRiskCount; int get tokenIntelCount; TokenAssociatedIntelsState get tokenAssociatedIntelsState; List<Intel>? get tokenAssociatedIntels; TokenDetailSecurityState get tokenDetailSecurityState; TokenDetailIntelState get tokenDetailIntelState; TokenDetailInfoState get tokenDetailInfoState; TokenDetailUrlsState get tokenDetailUrlsState; TokenHoldingsState get tokenHoldingsState; TokenIntelCountState get tokenIntelCountState; String? get tokenType;
/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TokenDetailStateCopyWith<TokenDetailState> get copyWith => _$TokenDetailStateCopyWithImpl<TokenDetailState>(this as TokenDetailState, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TokenDetailState&&const DeepCollectionEquality().equals(other.token, token)&&(identical(other.securitys, securitys) || other.securitys == securitys)&&(identical(other.tokenDetailInfo, tokenDetailInfo) || other.tokenDetailInfo == tokenDetailInfo)&&(identical(other.tokenAssociatedIntelsPage, tokenAssociatedIntelsPage) || other.tokenAssociatedIntelsPage == tokenAssociatedIntelsPage)&&(identical(other.tokenAssociatedIntelsPageSize, tokenAssociatedIntelsPageSize) || other.tokenAssociatedIntelsPageSize == tokenAssociatedIntelsPageSize)&&const DeepCollectionEquality().equals(other.tokenHoldings, tokenHoldings)&&(identical(other.isNotMore, isNotMore) || other.isNotMore == isNotMore)&&(identical(other.tokenUrls, tokenUrls) || other.tokenUrls == tokenUrls)&&(identical(other.tokenRiskCount, tokenRiskCount) || other.tokenRiskCount == tokenRiskCount)&&(identical(other.tokenIntelCount, tokenIntelCount) || other.tokenIntelCount == tokenIntelCount)&&(identical(other.tokenAssociatedIntelsState, tokenAssociatedIntelsState) || other.tokenAssociatedIntelsState == tokenAssociatedIntelsState)&&const DeepCollectionEquality().equals(other.tokenAssociatedIntels, tokenAssociatedIntels)&&(identical(other.tokenDetailSecurityState, tokenDetailSecurityState) || other.tokenDetailSecurityState == tokenDetailSecurityState)&&(identical(other.tokenDetailIntelState, tokenDetailIntelState) || other.tokenDetailIntelState == tokenDetailIntelState)&&(identical(other.tokenDetailInfoState, tokenDetailInfoState) || other.tokenDetailInfoState == tokenDetailInfoState)&&(identical(other.tokenDetailUrlsState, tokenDetailUrlsState) || other.tokenDetailUrlsState == tokenDetailUrlsState)&&(identical(other.tokenHoldingsState, tokenHoldingsState) || other.tokenHoldingsState == tokenHoldingsState)&&(identical(other.tokenIntelCountState, tokenIntelCountState) || other.tokenIntelCountState == tokenIntelCountState)&&(identical(other.tokenType, tokenType) || other.tokenType == tokenType));
}


@override
int get hashCode => Object.hashAll([runtimeType,const DeepCollectionEquality().hash(token),securitys,tokenDetailInfo,tokenAssociatedIntelsPage,tokenAssociatedIntelsPageSize,const DeepCollectionEquality().hash(tokenHoldings),isNotMore,tokenUrls,tokenRiskCount,tokenIntelCount,tokenAssociatedIntelsState,const DeepCollectionEquality().hash(tokenAssociatedIntels),tokenDetailSecurityState,tokenDetailIntelState,tokenDetailInfoState,tokenDetailUrlsState,tokenHoldingsState,tokenIntelCountState,tokenType]);

@override
String toString() {
  return 'TokenDetailState(token: $token, securitys: $securitys, tokenDetailInfo: $tokenDetailInfo, tokenAssociatedIntelsPage: $tokenAssociatedIntelsPage, tokenAssociatedIntelsPageSize: $tokenAssociatedIntelsPageSize, tokenHoldings: $tokenHoldings, isNotMore: $isNotMore, tokenUrls: $tokenUrls, tokenRiskCount: $tokenRiskCount, tokenIntelCount: $tokenIntelCount, tokenAssociatedIntelsState: $tokenAssociatedIntelsState, tokenAssociatedIntels: $tokenAssociatedIntels, tokenDetailSecurityState: $tokenDetailSecurityState, tokenDetailIntelState: $tokenDetailIntelState, tokenDetailInfoState: $tokenDetailInfoState, tokenDetailUrlsState: $tokenDetailUrlsState, tokenHoldingsState: $tokenHoldingsState, tokenIntelCountState: $tokenIntelCountState, tokenType: $tokenType)';
}


}

/// @nodoc
abstract mixin class $TokenDetailStateCopyWith<$Res>  {
  factory $TokenDetailStateCopyWith(TokenDetailState value, $Res Function(TokenDetailState) _then) = _$TokenDetailStateCopyWithImpl;
@useResult
$Res call({
 Token? token, TokenDetailSecurity? securitys, TokenDetailInfo? tokenDetailInfo, int tokenAssociatedIntelsPage, int tokenAssociatedIntelsPageSize, List<dynamic>? tokenHoldings, bool isNotMore, TokenDetailUrls? tokenUrls, int tokenRiskCount, int tokenIntelCount, TokenAssociatedIntelsState tokenAssociatedIntelsState, List<Intel>? tokenAssociatedIntels, TokenDetailSecurityState tokenDetailSecurityState, TokenDetailIntelState tokenDetailIntelState, TokenDetailInfoState tokenDetailInfoState, TokenDetailUrlsState tokenDetailUrlsState, TokenHoldingsState tokenHoldingsState, TokenIntelCountState tokenIntelCountState, String? tokenType
});


$TokenDetailSecurityCopyWith<$Res>? get securitys;$TokenDetailInfoCopyWith<$Res>? get tokenDetailInfo;$TokenDetailUrlsCopyWith<$Res>? get tokenUrls;$TokenAssociatedIntelsStateCopyWith<$Res> get tokenAssociatedIntelsState;$TokenDetailSecurityStateCopyWith<$Res> get tokenDetailSecurityState;$TokenDetailIntelStateCopyWith<$Res> get tokenDetailIntelState;$TokenDetailInfoStateCopyWith<$Res> get tokenDetailInfoState;$TokenDetailUrlsStateCopyWith<$Res> get tokenDetailUrlsState;$TokenHoldingsStateCopyWith<$Res> get tokenHoldingsState;$TokenIntelCountStateCopyWith<$Res> get tokenIntelCountState;

}
/// @nodoc
class _$TokenDetailStateCopyWithImpl<$Res>
    implements $TokenDetailStateCopyWith<$Res> {
  _$TokenDetailStateCopyWithImpl(this._self, this._then);

  final TokenDetailState _self;
  final $Res Function(TokenDetailState) _then;

/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? token = freezed,Object? securitys = freezed,Object? tokenDetailInfo = freezed,Object? tokenAssociatedIntelsPage = null,Object? tokenAssociatedIntelsPageSize = null,Object? tokenHoldings = freezed,Object? isNotMore = null,Object? tokenUrls = freezed,Object? tokenRiskCount = null,Object? tokenIntelCount = null,Object? tokenAssociatedIntelsState = null,Object? tokenAssociatedIntels = freezed,Object? tokenDetailSecurityState = null,Object? tokenDetailIntelState = null,Object? tokenDetailInfoState = null,Object? tokenDetailUrlsState = null,Object? tokenHoldingsState = null,Object? tokenIntelCountState = null,Object? tokenType = freezed,}) {
  return _then(_self.copyWith(
token: freezed == token ? _self.token : token // ignore: cast_nullable_to_non_nullable
as Token?,securitys: freezed == securitys ? _self.securitys : securitys // ignore: cast_nullable_to_non_nullable
as TokenDetailSecurity?,tokenDetailInfo: freezed == tokenDetailInfo ? _self.tokenDetailInfo : tokenDetailInfo // ignore: cast_nullable_to_non_nullable
as TokenDetailInfo?,tokenAssociatedIntelsPage: null == tokenAssociatedIntelsPage ? _self.tokenAssociatedIntelsPage : tokenAssociatedIntelsPage // ignore: cast_nullable_to_non_nullable
as int,tokenAssociatedIntelsPageSize: null == tokenAssociatedIntelsPageSize ? _self.tokenAssociatedIntelsPageSize : tokenAssociatedIntelsPageSize // ignore: cast_nullable_to_non_nullable
as int,tokenHoldings: freezed == tokenHoldings ? _self.tokenHoldings : tokenHoldings // ignore: cast_nullable_to_non_nullable
as List<dynamic>?,isNotMore: null == isNotMore ? _self.isNotMore : isNotMore // ignore: cast_nullable_to_non_nullable
as bool,tokenUrls: freezed == tokenUrls ? _self.tokenUrls : tokenUrls // ignore: cast_nullable_to_non_nullable
as TokenDetailUrls?,tokenRiskCount: null == tokenRiskCount ? _self.tokenRiskCount : tokenRiskCount // ignore: cast_nullable_to_non_nullable
as int,tokenIntelCount: null == tokenIntelCount ? _self.tokenIntelCount : tokenIntelCount // ignore: cast_nullable_to_non_nullable
as int,tokenAssociatedIntelsState: null == tokenAssociatedIntelsState ? _self.tokenAssociatedIntelsState : tokenAssociatedIntelsState // ignore: cast_nullable_to_non_nullable
as TokenAssociatedIntelsState,tokenAssociatedIntels: freezed == tokenAssociatedIntels ? _self.tokenAssociatedIntels : tokenAssociatedIntels // ignore: cast_nullable_to_non_nullable
as List<Intel>?,tokenDetailSecurityState: null == tokenDetailSecurityState ? _self.tokenDetailSecurityState : tokenDetailSecurityState // ignore: cast_nullable_to_non_nullable
as TokenDetailSecurityState,tokenDetailIntelState: null == tokenDetailIntelState ? _self.tokenDetailIntelState : tokenDetailIntelState // ignore: cast_nullable_to_non_nullable
as TokenDetailIntelState,tokenDetailInfoState: null == tokenDetailInfoState ? _self.tokenDetailInfoState : tokenDetailInfoState // ignore: cast_nullable_to_non_nullable
as TokenDetailInfoState,tokenDetailUrlsState: null == tokenDetailUrlsState ? _self.tokenDetailUrlsState : tokenDetailUrlsState // ignore: cast_nullable_to_non_nullable
as TokenDetailUrlsState,tokenHoldingsState: null == tokenHoldingsState ? _self.tokenHoldingsState : tokenHoldingsState // ignore: cast_nullable_to_non_nullable
as TokenHoldingsState,tokenIntelCountState: null == tokenIntelCountState ? _self.tokenIntelCountState : tokenIntelCountState // ignore: cast_nullable_to_non_nullable
as TokenIntelCountState,tokenType: freezed == tokenType ? _self.tokenType : tokenType // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}
/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenDetailSecurityCopyWith<$Res>? get securitys {
    if (_self.securitys == null) {
    return null;
  }

  return $TokenDetailSecurityCopyWith<$Res>(_self.securitys!, (value) {
    return _then(_self.copyWith(securitys: value));
  });
}/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenDetailInfoCopyWith<$Res>? get tokenDetailInfo {
    if (_self.tokenDetailInfo == null) {
    return null;
  }

  return $TokenDetailInfoCopyWith<$Res>(_self.tokenDetailInfo!, (value) {
    return _then(_self.copyWith(tokenDetailInfo: value));
  });
}/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenDetailUrlsCopyWith<$Res>? get tokenUrls {
    if (_self.tokenUrls == null) {
    return null;
  }

  return $TokenDetailUrlsCopyWith<$Res>(_self.tokenUrls!, (value) {
    return _then(_self.copyWith(tokenUrls: value));
  });
}/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenAssociatedIntelsStateCopyWith<$Res> get tokenAssociatedIntelsState {
  
  return $TokenAssociatedIntelsStateCopyWith<$Res>(_self.tokenAssociatedIntelsState, (value) {
    return _then(_self.copyWith(tokenAssociatedIntelsState: value));
  });
}/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenDetailSecurityStateCopyWith<$Res> get tokenDetailSecurityState {
  
  return $TokenDetailSecurityStateCopyWith<$Res>(_self.tokenDetailSecurityState, (value) {
    return _then(_self.copyWith(tokenDetailSecurityState: value));
  });
}/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenDetailIntelStateCopyWith<$Res> get tokenDetailIntelState {
  
  return $TokenDetailIntelStateCopyWith<$Res>(_self.tokenDetailIntelState, (value) {
    return _then(_self.copyWith(tokenDetailIntelState: value));
  });
}/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenDetailInfoStateCopyWith<$Res> get tokenDetailInfoState {
  
  return $TokenDetailInfoStateCopyWith<$Res>(_self.tokenDetailInfoState, (value) {
    return _then(_self.copyWith(tokenDetailInfoState: value));
  });
}/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenDetailUrlsStateCopyWith<$Res> get tokenDetailUrlsState {
  
  return $TokenDetailUrlsStateCopyWith<$Res>(_self.tokenDetailUrlsState, (value) {
    return _then(_self.copyWith(tokenDetailUrlsState: value));
  });
}/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenHoldingsStateCopyWith<$Res> get tokenHoldingsState {
  
  return $TokenHoldingsStateCopyWith<$Res>(_self.tokenHoldingsState, (value) {
    return _then(_self.copyWith(tokenHoldingsState: value));
  });
}/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenIntelCountStateCopyWith<$Res> get tokenIntelCountState {
  
  return $TokenIntelCountStateCopyWith<$Res>(_self.tokenIntelCountState, (value) {
    return _then(_self.copyWith(tokenIntelCountState: value));
  });
}
}


/// Adds pattern-matching-related methods to [TokenDetailState].
extension TokenDetailStatePatterns on TokenDetailState {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _TokenDetailState value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _TokenDetailState() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _TokenDetailState value)  $default,){
final _that = this;
switch (_that) {
case _TokenDetailState():
return $default(_that);}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _TokenDetailState value)?  $default,){
final _that = this;
switch (_that) {
case _TokenDetailState() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( Token? token,  TokenDetailSecurity? securitys,  TokenDetailInfo? tokenDetailInfo,  int tokenAssociatedIntelsPage,  int tokenAssociatedIntelsPageSize,  List<dynamic>? tokenHoldings,  bool isNotMore,  TokenDetailUrls? tokenUrls,  int tokenRiskCount,  int tokenIntelCount,  TokenAssociatedIntelsState tokenAssociatedIntelsState,  List<Intel>? tokenAssociatedIntels,  TokenDetailSecurityState tokenDetailSecurityState,  TokenDetailIntelState tokenDetailIntelState,  TokenDetailInfoState tokenDetailInfoState,  TokenDetailUrlsState tokenDetailUrlsState,  TokenHoldingsState tokenHoldingsState,  TokenIntelCountState tokenIntelCountState,  String? tokenType)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _TokenDetailState() when $default != null:
return $default(_that.token,_that.securitys,_that.tokenDetailInfo,_that.tokenAssociatedIntelsPage,_that.tokenAssociatedIntelsPageSize,_that.tokenHoldings,_that.isNotMore,_that.tokenUrls,_that.tokenRiskCount,_that.tokenIntelCount,_that.tokenAssociatedIntelsState,_that.tokenAssociatedIntels,_that.tokenDetailSecurityState,_that.tokenDetailIntelState,_that.tokenDetailInfoState,_that.tokenDetailUrlsState,_that.tokenHoldingsState,_that.tokenIntelCountState,_that.tokenType);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( Token? token,  TokenDetailSecurity? securitys,  TokenDetailInfo? tokenDetailInfo,  int tokenAssociatedIntelsPage,  int tokenAssociatedIntelsPageSize,  List<dynamic>? tokenHoldings,  bool isNotMore,  TokenDetailUrls? tokenUrls,  int tokenRiskCount,  int tokenIntelCount,  TokenAssociatedIntelsState tokenAssociatedIntelsState,  List<Intel>? tokenAssociatedIntels,  TokenDetailSecurityState tokenDetailSecurityState,  TokenDetailIntelState tokenDetailIntelState,  TokenDetailInfoState tokenDetailInfoState,  TokenDetailUrlsState tokenDetailUrlsState,  TokenHoldingsState tokenHoldingsState,  TokenIntelCountState tokenIntelCountState,  String? tokenType)  $default,) {final _that = this;
switch (_that) {
case _TokenDetailState():
return $default(_that.token,_that.securitys,_that.tokenDetailInfo,_that.tokenAssociatedIntelsPage,_that.tokenAssociatedIntelsPageSize,_that.tokenHoldings,_that.isNotMore,_that.tokenUrls,_that.tokenRiskCount,_that.tokenIntelCount,_that.tokenAssociatedIntelsState,_that.tokenAssociatedIntels,_that.tokenDetailSecurityState,_that.tokenDetailIntelState,_that.tokenDetailInfoState,_that.tokenDetailUrlsState,_that.tokenHoldingsState,_that.tokenIntelCountState,_that.tokenType);}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( Token? token,  TokenDetailSecurity? securitys,  TokenDetailInfo? tokenDetailInfo,  int tokenAssociatedIntelsPage,  int tokenAssociatedIntelsPageSize,  List<dynamic>? tokenHoldings,  bool isNotMore,  TokenDetailUrls? tokenUrls,  int tokenRiskCount,  int tokenIntelCount,  TokenAssociatedIntelsState tokenAssociatedIntelsState,  List<Intel>? tokenAssociatedIntels,  TokenDetailSecurityState tokenDetailSecurityState,  TokenDetailIntelState tokenDetailIntelState,  TokenDetailInfoState tokenDetailInfoState,  TokenDetailUrlsState tokenDetailUrlsState,  TokenHoldingsState tokenHoldingsState,  TokenIntelCountState tokenIntelCountState,  String? tokenType)?  $default,) {final _that = this;
switch (_that) {
case _TokenDetailState() when $default != null:
return $default(_that.token,_that.securitys,_that.tokenDetailInfo,_that.tokenAssociatedIntelsPage,_that.tokenAssociatedIntelsPageSize,_that.tokenHoldings,_that.isNotMore,_that.tokenUrls,_that.tokenRiskCount,_that.tokenIntelCount,_that.tokenAssociatedIntelsState,_that.tokenAssociatedIntels,_that.tokenDetailSecurityState,_that.tokenDetailIntelState,_that.tokenDetailInfoState,_that.tokenDetailUrlsState,_that.tokenHoldingsState,_that.tokenIntelCountState,_that.tokenType);case _:
  return null;

}
}

}

/// @nodoc


class _TokenDetailState extends TokenDetailState {
  const _TokenDetailState({this.token = null, this.securitys = null, this.tokenDetailInfo = null, this.tokenAssociatedIntelsPage = 1, this.tokenAssociatedIntelsPageSize = 10, final  List<dynamic>? tokenHoldings = const [], this.isNotMore = false, this.tokenUrls = null, this.tokenRiskCount = 0, this.tokenIntelCount = 0, this.tokenAssociatedIntelsState = const TokenAssociatedIntelsState.initial(), final  List<Intel>? tokenAssociatedIntels = const [], this.tokenDetailSecurityState = const TokenDetailSecurityState.initial(), this.tokenDetailIntelState = const TokenDetailIntelState.initial(), this.tokenDetailInfoState = const TokenDetailInfoState.initial(), this.tokenDetailUrlsState = const TokenDetailUrlsState.initial(), this.tokenHoldingsState = const TokenHoldingsState.initial(), this.tokenIntelCountState = const TokenIntelCountState.initial(), this.tokenType = null}): _tokenHoldings = tokenHoldings,_tokenAssociatedIntels = tokenAssociatedIntels,super._();
  

@override@JsonKey() final  Token? token;
@override@JsonKey() final  TokenDetailSecurity? securitys;
@override@JsonKey() final  TokenDetailInfo? tokenDetailInfo;
@override@JsonKey() final  int tokenAssociatedIntelsPage;
@override@JsonKey() final  int tokenAssociatedIntelsPageSize;
 final  List<dynamic>? _tokenHoldings;
@override@JsonKey() List<dynamic>? get tokenHoldings {
  final value = _tokenHoldings;
  if (value == null) return null;
  if (_tokenHoldings is EqualUnmodifiableListView) return _tokenHoldings;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override@JsonKey() final  bool isNotMore;
@override@JsonKey() final  TokenDetailUrls? tokenUrls;
@override@JsonKey() final  int tokenRiskCount;
@override@JsonKey() final  int tokenIntelCount;
@override@JsonKey() final  TokenAssociatedIntelsState tokenAssociatedIntelsState;
 final  List<Intel>? _tokenAssociatedIntels;
@override@JsonKey() List<Intel>? get tokenAssociatedIntels {
  final value = _tokenAssociatedIntels;
  if (value == null) return null;
  if (_tokenAssociatedIntels is EqualUnmodifiableListView) return _tokenAssociatedIntels;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override@JsonKey() final  TokenDetailSecurityState tokenDetailSecurityState;
@override@JsonKey() final  TokenDetailIntelState tokenDetailIntelState;
@override@JsonKey() final  TokenDetailInfoState tokenDetailInfoState;
@override@JsonKey() final  TokenDetailUrlsState tokenDetailUrlsState;
@override@JsonKey() final  TokenHoldingsState tokenHoldingsState;
@override@JsonKey() final  TokenIntelCountState tokenIntelCountState;
@override@JsonKey() final  String? tokenType;

/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TokenDetailStateCopyWith<_TokenDetailState> get copyWith => __$TokenDetailStateCopyWithImpl<_TokenDetailState>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenDetailState&&const DeepCollectionEquality().equals(other.token, token)&&(identical(other.securitys, securitys) || other.securitys == securitys)&&(identical(other.tokenDetailInfo, tokenDetailInfo) || other.tokenDetailInfo == tokenDetailInfo)&&(identical(other.tokenAssociatedIntelsPage, tokenAssociatedIntelsPage) || other.tokenAssociatedIntelsPage == tokenAssociatedIntelsPage)&&(identical(other.tokenAssociatedIntelsPageSize, tokenAssociatedIntelsPageSize) || other.tokenAssociatedIntelsPageSize == tokenAssociatedIntelsPageSize)&&const DeepCollectionEquality().equals(other._tokenHoldings, _tokenHoldings)&&(identical(other.isNotMore, isNotMore) || other.isNotMore == isNotMore)&&(identical(other.tokenUrls, tokenUrls) || other.tokenUrls == tokenUrls)&&(identical(other.tokenRiskCount, tokenRiskCount) || other.tokenRiskCount == tokenRiskCount)&&(identical(other.tokenIntelCount, tokenIntelCount) || other.tokenIntelCount == tokenIntelCount)&&(identical(other.tokenAssociatedIntelsState, tokenAssociatedIntelsState) || other.tokenAssociatedIntelsState == tokenAssociatedIntelsState)&&const DeepCollectionEquality().equals(other._tokenAssociatedIntels, _tokenAssociatedIntels)&&(identical(other.tokenDetailSecurityState, tokenDetailSecurityState) || other.tokenDetailSecurityState == tokenDetailSecurityState)&&(identical(other.tokenDetailIntelState, tokenDetailIntelState) || other.tokenDetailIntelState == tokenDetailIntelState)&&(identical(other.tokenDetailInfoState, tokenDetailInfoState) || other.tokenDetailInfoState == tokenDetailInfoState)&&(identical(other.tokenDetailUrlsState, tokenDetailUrlsState) || other.tokenDetailUrlsState == tokenDetailUrlsState)&&(identical(other.tokenHoldingsState, tokenHoldingsState) || other.tokenHoldingsState == tokenHoldingsState)&&(identical(other.tokenIntelCountState, tokenIntelCountState) || other.tokenIntelCountState == tokenIntelCountState)&&(identical(other.tokenType, tokenType) || other.tokenType == tokenType));
}


@override
int get hashCode => Object.hashAll([runtimeType,const DeepCollectionEquality().hash(token),securitys,tokenDetailInfo,tokenAssociatedIntelsPage,tokenAssociatedIntelsPageSize,const DeepCollectionEquality().hash(_tokenHoldings),isNotMore,tokenUrls,tokenRiskCount,tokenIntelCount,tokenAssociatedIntelsState,const DeepCollectionEquality().hash(_tokenAssociatedIntels),tokenDetailSecurityState,tokenDetailIntelState,tokenDetailInfoState,tokenDetailUrlsState,tokenHoldingsState,tokenIntelCountState,tokenType]);

@override
String toString() {
  return 'TokenDetailState(token: $token, securitys: $securitys, tokenDetailInfo: $tokenDetailInfo, tokenAssociatedIntelsPage: $tokenAssociatedIntelsPage, tokenAssociatedIntelsPageSize: $tokenAssociatedIntelsPageSize, tokenHoldings: $tokenHoldings, isNotMore: $isNotMore, tokenUrls: $tokenUrls, tokenRiskCount: $tokenRiskCount, tokenIntelCount: $tokenIntelCount, tokenAssociatedIntelsState: $tokenAssociatedIntelsState, tokenAssociatedIntels: $tokenAssociatedIntels, tokenDetailSecurityState: $tokenDetailSecurityState, tokenDetailIntelState: $tokenDetailIntelState, tokenDetailInfoState: $tokenDetailInfoState, tokenDetailUrlsState: $tokenDetailUrlsState, tokenHoldingsState: $tokenHoldingsState, tokenIntelCountState: $tokenIntelCountState, tokenType: $tokenType)';
}


}

/// @nodoc
abstract mixin class _$TokenDetailStateCopyWith<$Res> implements $TokenDetailStateCopyWith<$Res> {
  factory _$TokenDetailStateCopyWith(_TokenDetailState value, $Res Function(_TokenDetailState) _then) = __$TokenDetailStateCopyWithImpl;
@override @useResult
$Res call({
 Token? token, TokenDetailSecurity? securitys, TokenDetailInfo? tokenDetailInfo, int tokenAssociatedIntelsPage, int tokenAssociatedIntelsPageSize, List<dynamic>? tokenHoldings, bool isNotMore, TokenDetailUrls? tokenUrls, int tokenRiskCount, int tokenIntelCount, TokenAssociatedIntelsState tokenAssociatedIntelsState, List<Intel>? tokenAssociatedIntels, TokenDetailSecurityState tokenDetailSecurityState, TokenDetailIntelState tokenDetailIntelState, TokenDetailInfoState tokenDetailInfoState, TokenDetailUrlsState tokenDetailUrlsState, TokenHoldingsState tokenHoldingsState, TokenIntelCountState tokenIntelCountState, String? tokenType
});


@override $TokenDetailSecurityCopyWith<$Res>? get securitys;@override $TokenDetailInfoCopyWith<$Res>? get tokenDetailInfo;@override $TokenDetailUrlsCopyWith<$Res>? get tokenUrls;@override $TokenAssociatedIntelsStateCopyWith<$Res> get tokenAssociatedIntelsState;@override $TokenDetailSecurityStateCopyWith<$Res> get tokenDetailSecurityState;@override $TokenDetailIntelStateCopyWith<$Res> get tokenDetailIntelState;@override $TokenDetailInfoStateCopyWith<$Res> get tokenDetailInfoState;@override $TokenDetailUrlsStateCopyWith<$Res> get tokenDetailUrlsState;@override $TokenHoldingsStateCopyWith<$Res> get tokenHoldingsState;@override $TokenIntelCountStateCopyWith<$Res> get tokenIntelCountState;

}
/// @nodoc
class __$TokenDetailStateCopyWithImpl<$Res>
    implements _$TokenDetailStateCopyWith<$Res> {
  __$TokenDetailStateCopyWithImpl(this._self, this._then);

  final _TokenDetailState _self;
  final $Res Function(_TokenDetailState) _then;

/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? token = freezed,Object? securitys = freezed,Object? tokenDetailInfo = freezed,Object? tokenAssociatedIntelsPage = null,Object? tokenAssociatedIntelsPageSize = null,Object? tokenHoldings = freezed,Object? isNotMore = null,Object? tokenUrls = freezed,Object? tokenRiskCount = null,Object? tokenIntelCount = null,Object? tokenAssociatedIntelsState = null,Object? tokenAssociatedIntels = freezed,Object? tokenDetailSecurityState = null,Object? tokenDetailIntelState = null,Object? tokenDetailInfoState = null,Object? tokenDetailUrlsState = null,Object? tokenHoldingsState = null,Object? tokenIntelCountState = null,Object? tokenType = freezed,}) {
  return _then(_TokenDetailState(
token: freezed == token ? _self.token : token // ignore: cast_nullable_to_non_nullable
as Token?,securitys: freezed == securitys ? _self.securitys : securitys // ignore: cast_nullable_to_non_nullable
as TokenDetailSecurity?,tokenDetailInfo: freezed == tokenDetailInfo ? _self.tokenDetailInfo : tokenDetailInfo // ignore: cast_nullable_to_non_nullable
as TokenDetailInfo?,tokenAssociatedIntelsPage: null == tokenAssociatedIntelsPage ? _self.tokenAssociatedIntelsPage : tokenAssociatedIntelsPage // ignore: cast_nullable_to_non_nullable
as int,tokenAssociatedIntelsPageSize: null == tokenAssociatedIntelsPageSize ? _self.tokenAssociatedIntelsPageSize : tokenAssociatedIntelsPageSize // ignore: cast_nullable_to_non_nullable
as int,tokenHoldings: freezed == tokenHoldings ? _self._tokenHoldings : tokenHoldings // ignore: cast_nullable_to_non_nullable
as List<dynamic>?,isNotMore: null == isNotMore ? _self.isNotMore : isNotMore // ignore: cast_nullable_to_non_nullable
as bool,tokenUrls: freezed == tokenUrls ? _self.tokenUrls : tokenUrls // ignore: cast_nullable_to_non_nullable
as TokenDetailUrls?,tokenRiskCount: null == tokenRiskCount ? _self.tokenRiskCount : tokenRiskCount // ignore: cast_nullable_to_non_nullable
as int,tokenIntelCount: null == tokenIntelCount ? _self.tokenIntelCount : tokenIntelCount // ignore: cast_nullable_to_non_nullable
as int,tokenAssociatedIntelsState: null == tokenAssociatedIntelsState ? _self.tokenAssociatedIntelsState : tokenAssociatedIntelsState // ignore: cast_nullable_to_non_nullable
as TokenAssociatedIntelsState,tokenAssociatedIntels: freezed == tokenAssociatedIntels ? _self._tokenAssociatedIntels : tokenAssociatedIntels // ignore: cast_nullable_to_non_nullable
as List<Intel>?,tokenDetailSecurityState: null == tokenDetailSecurityState ? _self.tokenDetailSecurityState : tokenDetailSecurityState // ignore: cast_nullable_to_non_nullable
as TokenDetailSecurityState,tokenDetailIntelState: null == tokenDetailIntelState ? _self.tokenDetailIntelState : tokenDetailIntelState // ignore: cast_nullable_to_non_nullable
as TokenDetailIntelState,tokenDetailInfoState: null == tokenDetailInfoState ? _self.tokenDetailInfoState : tokenDetailInfoState // ignore: cast_nullable_to_non_nullable
as TokenDetailInfoState,tokenDetailUrlsState: null == tokenDetailUrlsState ? _self.tokenDetailUrlsState : tokenDetailUrlsState // ignore: cast_nullable_to_non_nullable
as TokenDetailUrlsState,tokenHoldingsState: null == tokenHoldingsState ? _self.tokenHoldingsState : tokenHoldingsState // ignore: cast_nullable_to_non_nullable
as TokenHoldingsState,tokenIntelCountState: null == tokenIntelCountState ? _self.tokenIntelCountState : tokenIntelCountState // ignore: cast_nullable_to_non_nullable
as TokenIntelCountState,tokenType: freezed == tokenType ? _self.tokenType : tokenType // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenDetailSecurityCopyWith<$Res>? get securitys {
    if (_self.securitys == null) {
    return null;
  }

  return $TokenDetailSecurityCopyWith<$Res>(_self.securitys!, (value) {
    return _then(_self.copyWith(securitys: value));
  });
}/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenDetailInfoCopyWith<$Res>? get tokenDetailInfo {
    if (_self.tokenDetailInfo == null) {
    return null;
  }

  return $TokenDetailInfoCopyWith<$Res>(_self.tokenDetailInfo!, (value) {
    return _then(_self.copyWith(tokenDetailInfo: value));
  });
}/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenDetailUrlsCopyWith<$Res>? get tokenUrls {
    if (_self.tokenUrls == null) {
    return null;
  }

  return $TokenDetailUrlsCopyWith<$Res>(_self.tokenUrls!, (value) {
    return _then(_self.copyWith(tokenUrls: value));
  });
}/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenAssociatedIntelsStateCopyWith<$Res> get tokenAssociatedIntelsState {
  
  return $TokenAssociatedIntelsStateCopyWith<$Res>(_self.tokenAssociatedIntelsState, (value) {
    return _then(_self.copyWith(tokenAssociatedIntelsState: value));
  });
}/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenDetailSecurityStateCopyWith<$Res> get tokenDetailSecurityState {
  
  return $TokenDetailSecurityStateCopyWith<$Res>(_self.tokenDetailSecurityState, (value) {
    return _then(_self.copyWith(tokenDetailSecurityState: value));
  });
}/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenDetailIntelStateCopyWith<$Res> get tokenDetailIntelState {
  
  return $TokenDetailIntelStateCopyWith<$Res>(_self.tokenDetailIntelState, (value) {
    return _then(_self.copyWith(tokenDetailIntelState: value));
  });
}/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenDetailInfoStateCopyWith<$Res> get tokenDetailInfoState {
  
  return $TokenDetailInfoStateCopyWith<$Res>(_self.tokenDetailInfoState, (value) {
    return _then(_self.copyWith(tokenDetailInfoState: value));
  });
}/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenDetailUrlsStateCopyWith<$Res> get tokenDetailUrlsState {
  
  return $TokenDetailUrlsStateCopyWith<$Res>(_self.tokenDetailUrlsState, (value) {
    return _then(_self.copyWith(tokenDetailUrlsState: value));
  });
}/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenHoldingsStateCopyWith<$Res> get tokenHoldingsState {
  
  return $TokenHoldingsStateCopyWith<$Res>(_self.tokenHoldingsState, (value) {
    return _then(_self.copyWith(tokenHoldingsState: value));
  });
}/// Create a copy of TokenDetailState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenIntelCountStateCopyWith<$Res> get tokenIntelCountState {
  
  return $TokenIntelCountStateCopyWith<$Res>(_self.tokenIntelCountState, (value) {
    return _then(_self.copyWith(tokenIntelCountState: value));
  });
}
}

/// @nodoc
mixin _$TokenDetailInfoState {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TokenDetailInfoState);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenDetailInfoState()';
}


}

/// @nodoc
class $TokenDetailInfoStateCopyWith<$Res>  {
$TokenDetailInfoStateCopyWith(TokenDetailInfoState _, $Res Function(TokenDetailInfoState) __);
}


/// Adds pattern-matching-related methods to [TokenDetailInfoState].
extension TokenDetailInfoStatePatterns on TokenDetailInfoState {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _TokenDetailInfoInitial value)?  initial,TResult Function( _TokenDetailInfoLoading value)?  loading,TResult Function( _TokenDetailInfoSuccess value)?  success,TResult Function( _TokenDetailInfoError value)?  error,required TResult orElse(),}){
final _that = this;
switch (_that) {
case _TokenDetailInfoInitial() when initial != null:
return initial(_that);case _TokenDetailInfoLoading() when loading != null:
return loading(_that);case _TokenDetailInfoSuccess() when success != null:
return success(_that);case _TokenDetailInfoError() when error != null:
return error(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _TokenDetailInfoInitial value)  initial,required TResult Function( _TokenDetailInfoLoading value)  loading,required TResult Function( _TokenDetailInfoSuccess value)  success,required TResult Function( _TokenDetailInfoError value)  error,}){
final _that = this;
switch (_that) {
case _TokenDetailInfoInitial():
return initial(_that);case _TokenDetailInfoLoading():
return loading(_that);case _TokenDetailInfoSuccess():
return success(_that);case _TokenDetailInfoError():
return error(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _TokenDetailInfoInitial value)?  initial,TResult? Function( _TokenDetailInfoLoading value)?  loading,TResult? Function( _TokenDetailInfoSuccess value)?  success,TResult? Function( _TokenDetailInfoError value)?  error,}){
final _that = this;
switch (_that) {
case _TokenDetailInfoInitial() when initial != null:
return initial(_that);case _TokenDetailInfoLoading() when loading != null:
return loading(_that);case _TokenDetailInfoSuccess() when success != null:
return success(_that);case _TokenDetailInfoError() when error != null:
return error(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  initial,TResult Function()?  loading,TResult Function( TokenDetailInfo tokenDetailInfo)?  success,TResult Function( String message)?  error,required TResult orElse(),}) {final _that = this;
switch (_that) {
case _TokenDetailInfoInitial() when initial != null:
return initial();case _TokenDetailInfoLoading() when loading != null:
return loading();case _TokenDetailInfoSuccess() when success != null:
return success(_that.tokenDetailInfo);case _TokenDetailInfoError() when error != null:
return error(_that.message);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  initial,required TResult Function()  loading,required TResult Function( TokenDetailInfo tokenDetailInfo)  success,required TResult Function( String message)  error,}) {final _that = this;
switch (_that) {
case _TokenDetailInfoInitial():
return initial();case _TokenDetailInfoLoading():
return loading();case _TokenDetailInfoSuccess():
return success(_that.tokenDetailInfo);case _TokenDetailInfoError():
return error(_that.message);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  initial,TResult? Function()?  loading,TResult? Function( TokenDetailInfo tokenDetailInfo)?  success,TResult? Function( String message)?  error,}) {final _that = this;
switch (_that) {
case _TokenDetailInfoInitial() when initial != null:
return initial();case _TokenDetailInfoLoading() when loading != null:
return loading();case _TokenDetailInfoSuccess() when success != null:
return success(_that.tokenDetailInfo);case _TokenDetailInfoError() when error != null:
return error(_that.message);case _:
  return null;

}
}

}

/// @nodoc


class _TokenDetailInfoInitial implements TokenDetailInfoState {
  const _TokenDetailInfoInitial();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenDetailInfoInitial);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenDetailInfoState.initial()';
}


}




/// @nodoc


class _TokenDetailInfoLoading implements TokenDetailInfoState {
  const _TokenDetailInfoLoading();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenDetailInfoLoading);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenDetailInfoState.loading()';
}


}




/// @nodoc


class _TokenDetailInfoSuccess implements TokenDetailInfoState {
  const _TokenDetailInfoSuccess(this.tokenDetailInfo);
  

 final  TokenDetailInfo tokenDetailInfo;

/// Create a copy of TokenDetailInfoState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TokenDetailInfoSuccessCopyWith<_TokenDetailInfoSuccess> get copyWith => __$TokenDetailInfoSuccessCopyWithImpl<_TokenDetailInfoSuccess>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenDetailInfoSuccess&&(identical(other.tokenDetailInfo, tokenDetailInfo) || other.tokenDetailInfo == tokenDetailInfo));
}


@override
int get hashCode => Object.hash(runtimeType,tokenDetailInfo);

@override
String toString() {
  return 'TokenDetailInfoState.success(tokenDetailInfo: $tokenDetailInfo)';
}


}

/// @nodoc
abstract mixin class _$TokenDetailInfoSuccessCopyWith<$Res> implements $TokenDetailInfoStateCopyWith<$Res> {
  factory _$TokenDetailInfoSuccessCopyWith(_TokenDetailInfoSuccess value, $Res Function(_TokenDetailInfoSuccess) _then) = __$TokenDetailInfoSuccessCopyWithImpl;
@useResult
$Res call({
 TokenDetailInfo tokenDetailInfo
});


$TokenDetailInfoCopyWith<$Res> get tokenDetailInfo;

}
/// @nodoc
class __$TokenDetailInfoSuccessCopyWithImpl<$Res>
    implements _$TokenDetailInfoSuccessCopyWith<$Res> {
  __$TokenDetailInfoSuccessCopyWithImpl(this._self, this._then);

  final _TokenDetailInfoSuccess _self;
  final $Res Function(_TokenDetailInfoSuccess) _then;

/// Create a copy of TokenDetailInfoState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? tokenDetailInfo = null,}) {
  return _then(_TokenDetailInfoSuccess(
null == tokenDetailInfo ? _self.tokenDetailInfo : tokenDetailInfo // ignore: cast_nullable_to_non_nullable
as TokenDetailInfo,
  ));
}

/// Create a copy of TokenDetailInfoState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TokenDetailInfoCopyWith<$Res> get tokenDetailInfo {
  
  return $TokenDetailInfoCopyWith<$Res>(_self.tokenDetailInfo, (value) {
    return _then(_self.copyWith(tokenDetailInfo: value));
  });
}
}

/// @nodoc


class _TokenDetailInfoError implements TokenDetailInfoState {
  const _TokenDetailInfoError(this.message);
  

 final  String message;

/// Create a copy of TokenDetailInfoState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TokenDetailInfoErrorCopyWith<_TokenDetailInfoError> get copyWith => __$TokenDetailInfoErrorCopyWithImpl<_TokenDetailInfoError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenDetailInfoError&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'TokenDetailInfoState.error(message: $message)';
}


}

/// @nodoc
abstract mixin class _$TokenDetailInfoErrorCopyWith<$Res> implements $TokenDetailInfoStateCopyWith<$Res> {
  factory _$TokenDetailInfoErrorCopyWith(_TokenDetailInfoError value, $Res Function(_TokenDetailInfoError) _then) = __$TokenDetailInfoErrorCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class __$TokenDetailInfoErrorCopyWithImpl<$Res>
    implements _$TokenDetailInfoErrorCopyWith<$Res> {
  __$TokenDetailInfoErrorCopyWithImpl(this._self, this._then);

  final _TokenDetailInfoError _self;
  final $Res Function(_TokenDetailInfoError) _then;

/// Create a copy of TokenDetailInfoState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(_TokenDetailInfoError(
null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc
mixin _$TokenAssociatedIntelsState {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TokenAssociatedIntelsState);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenAssociatedIntelsState()';
}


}

/// @nodoc
class $TokenAssociatedIntelsStateCopyWith<$Res>  {
$TokenAssociatedIntelsStateCopyWith(TokenAssociatedIntelsState _, $Res Function(TokenAssociatedIntelsState) __);
}


/// Adds pattern-matching-related methods to [TokenAssociatedIntelsState].
extension TokenAssociatedIntelsStatePatterns on TokenAssociatedIntelsState {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _TokenAssociatedIntelsInitial value)?  initial,TResult Function( _TokenAssociatedIntelsLoading value)?  loading,TResult Function( _TokenAssociatedIntelsSuccess value)?  success,TResult Function( _TokenAssociatedIntelsError value)?  error,required TResult orElse(),}){
final _that = this;
switch (_that) {
case _TokenAssociatedIntelsInitial() when initial != null:
return initial(_that);case _TokenAssociatedIntelsLoading() when loading != null:
return loading(_that);case _TokenAssociatedIntelsSuccess() when success != null:
return success(_that);case _TokenAssociatedIntelsError() when error != null:
return error(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _TokenAssociatedIntelsInitial value)  initial,required TResult Function( _TokenAssociatedIntelsLoading value)  loading,required TResult Function( _TokenAssociatedIntelsSuccess value)  success,required TResult Function( _TokenAssociatedIntelsError value)  error,}){
final _that = this;
switch (_that) {
case _TokenAssociatedIntelsInitial():
return initial(_that);case _TokenAssociatedIntelsLoading():
return loading(_that);case _TokenAssociatedIntelsSuccess():
return success(_that);case _TokenAssociatedIntelsError():
return error(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _TokenAssociatedIntelsInitial value)?  initial,TResult? Function( _TokenAssociatedIntelsLoading value)?  loading,TResult? Function( _TokenAssociatedIntelsSuccess value)?  success,TResult? Function( _TokenAssociatedIntelsError value)?  error,}){
final _that = this;
switch (_that) {
case _TokenAssociatedIntelsInitial() when initial != null:
return initial(_that);case _TokenAssociatedIntelsLoading() when loading != null:
return loading(_that);case _TokenAssociatedIntelsSuccess() when success != null:
return success(_that);case _TokenAssociatedIntelsError() when error != null:
return error(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  initial,TResult Function()?  loading,TResult Function( List<Intel> tokenAssociatedIntels)?  success,TResult Function( String message)?  error,required TResult orElse(),}) {final _that = this;
switch (_that) {
case _TokenAssociatedIntelsInitial() when initial != null:
return initial();case _TokenAssociatedIntelsLoading() when loading != null:
return loading();case _TokenAssociatedIntelsSuccess() when success != null:
return success(_that.tokenAssociatedIntels);case _TokenAssociatedIntelsError() when error != null:
return error(_that.message);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  initial,required TResult Function()  loading,required TResult Function( List<Intel> tokenAssociatedIntels)  success,required TResult Function( String message)  error,}) {final _that = this;
switch (_that) {
case _TokenAssociatedIntelsInitial():
return initial();case _TokenAssociatedIntelsLoading():
return loading();case _TokenAssociatedIntelsSuccess():
return success(_that.tokenAssociatedIntels);case _TokenAssociatedIntelsError():
return error(_that.message);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  initial,TResult? Function()?  loading,TResult? Function( List<Intel> tokenAssociatedIntels)?  success,TResult? Function( String message)?  error,}) {final _that = this;
switch (_that) {
case _TokenAssociatedIntelsInitial() when initial != null:
return initial();case _TokenAssociatedIntelsLoading() when loading != null:
return loading();case _TokenAssociatedIntelsSuccess() when success != null:
return success(_that.tokenAssociatedIntels);case _TokenAssociatedIntelsError() when error != null:
return error(_that.message);case _:
  return null;

}
}

}

/// @nodoc


class _TokenAssociatedIntelsInitial implements TokenAssociatedIntelsState {
  const _TokenAssociatedIntelsInitial();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenAssociatedIntelsInitial);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenAssociatedIntelsState.initial()';
}


}




/// @nodoc


class _TokenAssociatedIntelsLoading implements TokenAssociatedIntelsState {
  const _TokenAssociatedIntelsLoading();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenAssociatedIntelsLoading);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TokenAssociatedIntelsState.loading()';
}


}




/// @nodoc


class _TokenAssociatedIntelsSuccess implements TokenAssociatedIntelsState {
  const _TokenAssociatedIntelsSuccess(final  List<Intel> tokenAssociatedIntels): _tokenAssociatedIntels = tokenAssociatedIntels;
  

 final  List<Intel> _tokenAssociatedIntels;
 List<Intel> get tokenAssociatedIntels {
  if (_tokenAssociatedIntels is EqualUnmodifiableListView) return _tokenAssociatedIntels;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_tokenAssociatedIntels);
}


/// Create a copy of TokenAssociatedIntelsState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TokenAssociatedIntelsSuccessCopyWith<_TokenAssociatedIntelsSuccess> get copyWith => __$TokenAssociatedIntelsSuccessCopyWithImpl<_TokenAssociatedIntelsSuccess>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenAssociatedIntelsSuccess&&const DeepCollectionEquality().equals(other._tokenAssociatedIntels, _tokenAssociatedIntels));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_tokenAssociatedIntels));

@override
String toString() {
  return 'TokenAssociatedIntelsState.success(tokenAssociatedIntels: $tokenAssociatedIntels)';
}


}

/// @nodoc
abstract mixin class _$TokenAssociatedIntelsSuccessCopyWith<$Res> implements $TokenAssociatedIntelsStateCopyWith<$Res> {
  factory _$TokenAssociatedIntelsSuccessCopyWith(_TokenAssociatedIntelsSuccess value, $Res Function(_TokenAssociatedIntelsSuccess) _then) = __$TokenAssociatedIntelsSuccessCopyWithImpl;
@useResult
$Res call({
 List<Intel> tokenAssociatedIntels
});




}
/// @nodoc
class __$TokenAssociatedIntelsSuccessCopyWithImpl<$Res>
    implements _$TokenAssociatedIntelsSuccessCopyWith<$Res> {
  __$TokenAssociatedIntelsSuccessCopyWithImpl(this._self, this._then);

  final _TokenAssociatedIntelsSuccess _self;
  final $Res Function(_TokenAssociatedIntelsSuccess) _then;

/// Create a copy of TokenAssociatedIntelsState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? tokenAssociatedIntels = null,}) {
  return _then(_TokenAssociatedIntelsSuccess(
null == tokenAssociatedIntels ? _self._tokenAssociatedIntels : tokenAssociatedIntels // ignore: cast_nullable_to_non_nullable
as List<Intel>,
  ));
}


}

/// @nodoc


class _TokenAssociatedIntelsError implements TokenAssociatedIntelsState {
  const _TokenAssociatedIntelsError(this.message);
  

 final  String message;

/// Create a copy of TokenAssociatedIntelsState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TokenAssociatedIntelsErrorCopyWith<_TokenAssociatedIntelsError> get copyWith => __$TokenAssociatedIntelsErrorCopyWithImpl<_TokenAssociatedIntelsError>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TokenAssociatedIntelsError&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'TokenAssociatedIntelsState.error(message: $message)';
}


}

/// @nodoc
abstract mixin class _$TokenAssociatedIntelsErrorCopyWith<$Res> implements $TokenAssociatedIntelsStateCopyWith<$Res> {
  factory _$TokenAssociatedIntelsErrorCopyWith(_TokenAssociatedIntelsError value, $Res Function(_TokenAssociatedIntelsError) _then) = __$TokenAssociatedIntelsErrorCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class __$TokenAssociatedIntelsErrorCopyWithImpl<$Res>
    implements _$TokenAssociatedIntelsErrorCopyWith<$Res> {
  __$TokenAssociatedIntelsErrorCopyWithImpl(this._self, this._then);

  final _TokenAssociatedIntelsError _self;
  final $Res Function(_TokenAssociatedIntelsError) _then;

/// Create a copy of TokenAssociatedIntelsState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(_TokenAssociatedIntelsError(
null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on
